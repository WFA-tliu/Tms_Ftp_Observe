###################################################################
# (c) Copyright 2008 Wi-Fi Alliance.  All Rights Reserved
#
# Authors:
# Chandra Sekhar Duba;       Email: cduba@wi-fi.org
####################################################################
# LICENSE
####################################################################
#
#
# License is granted only to Wi-Fi Alliance members and is for use solely
# in testing Wi-Fi products. This license is not transferable or sublicensable,
# and it does not extend to and may not be used with non Wi-Fi applications.
#
# Commercial derivative works or applications that use the Wi-Fi
# scripts generated by this software are NOT AUTHORIZED without
# specific prior written permission from Wi-Fi Alliance
#
# Non-commercial derivative works for your own internal use are
# authorized and are limited by the same restrictions.
#
# Neither the name of the author nor "Wi-Fi Alliance"
# may be used to endorse or promote products that are derived
# from or that use this software without specific prior written
# permission from the author or Wi-Fi Alliance
#
# THIS SOFTWARE IS PROVIDED BY WI-FI ALLIANCE "AS IS" AND ANY
# EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS
# FOR A  PARTICULAR PURPOSE, ARE DISCLAIMED. IN NO EVENT SHALL WI-FI
# ALLIANCE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# THE COST OF PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
###################################################################
# Change History
#       Date        Version          Comment 
#            
#        
###################################################################
#

import socket
import sys, os

from tms.TmsHeaders import *
import tms.TmsCommon as TmsCommon
import subprocess
import json
from pprint import pprint


class TmsLocalStorage:
    def __init__(self,_logobj):
        #logger object
        self.logobj = _logobj
        self.logobj.LogMsg("TmsLocalStorage - Object Created",WFA_INFO)

    def GetLogFile(self):
        self.logobj.LogMsg("Entry GetLogFile function",WFA_DEBUG)
        self.logobj.LogMsg("Exit GetLogFile function",WFA_DEBUG)

    def GetLocalStorageStatus(self):
        self.logobj.LogMsg("Entry GetLocalStorageStatus function",WFA_DEBUG)
        #Check the JSON files from the directory
        cmd="dir "+TmsCommon.TmsLocalStoragePath+"*.json /od" 
        print("the command", cmd)
        ret=os.path.exists(TmsCommon.TmsLocalStoragePath) 
        if(ret == False):
            print("Local Storage folder not exist!!!")
            sys.exit(0)
        try: 
            cmd_output=str(subprocess.check_output(cmd, shell=True))
        except: 
            print("No JSON files in the local storage")
            sys.exit(1)
        else:
            print("The command output is", cmd_output)
            print("The type of command output is", type(cmd_output))
            tmp1=cmd_output.split("\n")
            tmp_count=0
            for tmp2 in tmp1:
                filename = tmp2.lower()
                # check the filename is json file
                if filename.find('json') > 0:
                    print("the file to be fetched", tmp2)
                    tmp_count=tmp_count+1
        print("The Total JSON files in the local storage: ",tmp_count)
        self.logobj.LogMsg("Exit GetLocalStorageStatus function",WFA_DEBUG)
        return tmp_count
		
    def GetJsonFile(self,_order="older"):
        self.logobj.LogMsg("Entry GetJsonFile function",WFA_DEBUG)
        #Check and pick the oldest JSON file from the directory
        if _order == "older" :
            cmd="dir "+TmsCommon.TmsLocalStoragePath+"*.json /od" 
        else:
            cmd="dir "+TmsCommon.TmsLocalStoragePath+"*.json /o-d" 
        cmd_option=TmsCommon.TmsLocalStoragePath+"*.json"
        #print "the command", cmd
        ret=os.path.exists(TmsCommon.TmsLocalStoragePath) 
        if(ret == False):
            print("Local Storage folder not exist!!!")
            sys.exit(1)
        try:
            cmd_output=str(subprocess.check_output(cmd, shell=True))
        except:
            print("Error in running the command ", cmd)
            sys.exit(1)

        #print "The command output ",cmd_output
        msg = "The command output %s", cmd_output
        self.logobj.LogMsg(msg,WFA_DEBUG)
        tmp1=cmd_output.split("\\r\\n")
        json_file=""
        for tmp2 in tmp1:
            filename = tmp2.lower()
		    # check the filename is json file
            if filename.find('json') > 0:
                #print "the file to be fetched", tmp2
                file_tmp=tmp2.split(" ")
                json_file=file_tmp[-1].rstrip()
                print("The json file to be posted to TMS Server", json_file) 
                break 
        if json_file != "":
            json_file_path= TmsCommon.TmsLocalStoragePath+json_file
        else:
            print("No Json file to selected")
            sys.exit(1)
        #Read the config file and assign the values
        try:
            fo = open(json_file_path, "r")
        except:
            print("Error opening Json file!!!")
            sys.exit(1)

        #with open(json_file_path) as data_file:    
        #    data = json.load(data_file)
        #pprint(data)
        JsonContents = fo.read()
        fo.close()
        #print "JSON contents", JsonContents
        self.logobj.LogMsg("Exit GetJsonFile function",WFA_DEBUG)
        return (JsonContents,json_file_path)
        #return data
          
